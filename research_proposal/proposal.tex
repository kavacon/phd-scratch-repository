\documentclass[journal,onecolumn, compsoc]{IEEEtran}

% Packages
\usepackage[utf8]{inputenc}
\usepackage{times}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{setspace}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{cite}  % For IEEE-style citations
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{float}

% Spacing
\doublespacing

% Title
\title{PhD Research Proposal\\\large{Compilable high level quantum computing languages}}
\author{Constantinos Kavadias\\Computing and Information Systems\\University of Melbourne}
\date{\today}

% Section formatting
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}

\begin{document}

% Title Page
\maketitle

% Table of Contents
\newpage
\tableofcontents
\newpage

% Abstract
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}
This proposal outlines the scope, context, and structure of the proposed PhD research.

% Introduction
\section{Introduction}
This research aims to explore and resolve the missing link between high-level programming languages and quantum programming.

In the last 10 years profound progress has been made towards unlocking higher level and interoperable quantum programming languages.

OpenQASM (Open Quantum Assembly Language) is a low-level quantum programming language introduced in 2017. OpenQASM provides a hardware-agnostic interface for specifying quantum operations and control sequences. It abstracts the quantum circuit, with a focus on gate-level instructions, expressing quantum algorithms directly in terms of qubits, gates, and measurements \cite{cross2017open}.

While powerful for precise quantum hardware control, OpenQASM lacks high-level abstractions, such as quantum-native control flows or modular algorithm design, often present in classical high-level languages.

Built on top of QASM we see progress towards high-level, C or Java-like languages. For instance, \textbf{Qiskit}~\cite{qiskit} and \textbf{PennyLane QML}~\cite{pennylane} provide Python-based interfaces that facilitate quantum programming, yet they rely heavily on low-level constructs and manual control flows.
Despite recent progress, most quantum programming languages remain close to circuit-level abstractions, requiring users to manipulate gates and qubits explicitly.

Efforts toward higher-level abstractions include \textbf{Silq}~\cite{silq2024}, \textbf{Qmod}~\cite{qmod2025}, \textbf{Qrisp}~\cite{qrisp2024}, \textbf{Qutes}~\cite{qutes2025}, and \textbf{ONDA}~\cite{onda2024}. \textbf{Silq} introduces automatic uncomputation, reducing programmer overhead, and improving type safety. \textbf{Qmod} emphasizes quantum-native numeric types and high-level expressiveness. \textbf{Qrisp} brings software engineering paradigms into quantum development, with the aim of maintainability and abstraction. \textbf{Qutes} simplifies quantum development by abstracting hardware details while remaining interoperable with Qiskit. \textbf{ONDA} incorporates conditional branching and sequential logic, approaching the structure of classical control flows within a quantum context.

These languages represent significant advances, but are still emerging, with limited adoption and tooling. None fully match the abstraction levels found in mature classical languages like C or Python.

At their core, these languages still rely on circuit primitives or bit-wise operations and a fundamental understanding of how these operate in a quantum mechanical context.
An ideal high-level language would abstract the need for this in depth understanding and provide new, operational abstractions instead.
\textbf{Quff}~\cite{quff2024}, a high-level C-like quantum language, provides a push in the right direction to achieve this result. 

\textbf{Quff} like the other examples provided still relies on dynamically generated circuits, requiring a classical machine to be involved in its compilation.
Our current high-level quantum languages are not yet ready to support a general purpose QPU with static circuit structures.

We aim with this research to address the remaining gaps in existing high-level quantum languages by defining new high-level software operations for quantum programs, paradigms for compiling them into low-level assembly and circuits and a programming language that describes the new operations.

Our research will focus on a language capable of running to completion on a standalone QPU. 
It is not a focus or within our initial scope to explore or develop implementations of quantum random access memory or storage.

% Research Design
\section{Research Design}
\subsection{Research Aims}
The study aims to achieve the following outcomes which will form the basis for a high-level quantum software paradigm and programming language.
\begin{itemize}
    \item Defining quantum operation (not bit-wise) primitives and their associated circuit structures.
    \item Defining a new quantum programming language and syntax built with these operations.
    \item Building an OpenQASM compiler for our language for dynamic circuit generation.
    \item Defining a novel general purpose circuit structure and microcode architecture for static compilation.
\end{itemize}

The language will be unique in that it will not require an understanding of circuit registers or quantum mechanics to be used.
Instead, we will develop a quantum programming language in which data can be defined intuitively as in classical languages such as C.
Quantum gates such as the Hadamard, CNOT and rotations will not be considered primary operations in this language, which will instead abstract the effects of these operators into well-defined software operations and functions.
The language will define new, quantum specific operations that may not have analgoues in classical languages but can described and taught based on their software outcomes rather than physical or quantum mechnical outcomes.

We will answer the following questions with our research:
\begin{itemize}
    \item Can quantum operations be abstracted away from bit-wise actions?
    \item Can a high-level programming language provide sufficient flexbility with more abstraction for non-expert quantum programmers?
    \item Can generic quantum programs be run on a static and shared circuit structure?
\end{itemize}

By building a new quantum programming language with novel compilation techniques we can answer these questions.

\subsection{Methodology}
We will use the Constructive Research Method, which is well-suited for the development of innovative artifacts in computing \cite{lukka2003constructive}. 

The methodology focuses on constructing a novel programming language grounded in theoretical analysis of quantum programming limitations. 
The process includes the systematic design, development, and demonstration of the language, followed by evaluation through case studies and comparisons with existing approaches. 
Emphasis is placed on the practical relevance of the artifact as a solution to real-world problems in quantum software engineering.

The \textit{Constructive Research Method} is applied in computer science for developing practical artifacts. Examples include work on trans-disciplinary innovation~\cite{mcgregor2018}, studies on computational models~\cite{dodig2010}, and guidelines for industry-related software tools~\cite{lassenius2001}.

\subsection{Success Criteria}
Our research will focus on physical outcomes and the development of a project.
Success will be measured based on the completion of each milestone and its ability to meet its objectives as outlined in Section~\ref{sec:timeline-plan}.

The research must meet the following general outcomes to be considered successful:
\begin{itemize}
    \item Creation of a high-level and compilable quantum programming language.
    \item Successful writing and running of a program in that language on quantum hardware.
    \item Presented evidence of the ability for non-experts in quantum computation to use the language.
\end{itemize}

% Timeline and Plan
\section{Timeline and Plan}\label{sec:timeline-plan}

\begin{table}[H]
\centering
\caption{PhD Timeline and Milestones}
\begin{tabular}{@{}c|c|p{6cm}|p{5cm}@{}}
\toprule
\textbf{Year} & \textbf{Milestone} & \textbf{Tasks} & \textbf{Expected Outcomes} \\
\midrule

Year 1 
& Define Quantum Operations 
& - Literature review of existing quantum circuit primitives \newline
  - Compile common quantum operations and related circuits \newline
  - Select control flow circuits for quantum programs 
& - Defined high-level operations \newline
  - Paper on review and defined operations \\
\midrule

\multirow{2}{*}{Year 2} 
& Programming Languages Refresher 
& - Take refresher classes on language design \newline
  - Study context-free grammars and parsing 
& - Strong foundation in language design for quantum context \\
\cmidrule{2-4}

& \multirow{2}{*}{Define High-Level Language} 
& - Define syntax and keywords \newline
  - Map quantum operations to language structures \newline
  - Write proof-of-concept programs (e.g., Grover's algorithm) 
& - Language specification \newline
  - Paper on high-level quantum language design \\
\cline{1-1} % Draws horizontal line only under "Year 3" in the first column

Year 3 
&  
& - Finalize language features \newline
  - Refine proof-of-concept implementations 
& - Completed high-level language prototype \\
\cmidrule{2-4}

\multirow{1}{*}{} 
& Develop Dynamic Compiler 
& - Build QASM compiler for defined language \newline
  - Test output on simulators and hardware 
& - Dynamic compiler prototype \newline
  - Demonstrated execution results \\
\midrule

\multirow{2}{*}{Year 4} 
& Build Static Circuit Compiler 
& - Define static circuit model and quantum latches \newline
  - Define microcode instructions and QASM output \newline
  - Develop static compilation pipeline 
& - Static compiler implementation \newline
  - Paper comparing static vs. dynamic compilation \\
\cmidrule{2-4}

& Compile Thesis 
& - Write and edit final dissertation 
& - Submitted PhD thesis \\
\bottomrule
\end{tabular}
\end{table}




% Thesis Structure
\section{Thesis Structure}
Section~\ref{sec:timeline-plan} provides an in depth overview of the milestones and tasks associated with the research.

There are 3 proposed publications that will be the outcomes of these milestones.
\begin{enumerate}
    \item Defining High-Level Quantum Software operations
    \item Specification and Proof for High-Level Quantum Programming Language
    \item Static and Dynamic Compilation of High-Level Quantum Programming Languages
\end{enumerate}

These 3 publications will also form the basis of the final thesis and its chapters.

The thesis will include Chapters as outlined below:

\begin{table}[H]
\centering
\caption{Structure of the PhD Thesis}
\begin{tabular}{@{}p{4cm} p{10cm}@{}}
\toprule
\textbf{Chapter} & \textbf{Content Description} \\
\midrule

Introduction & Outlines the motivation for accessible quantum programming, the challenges in abstraction and portability, and the objectives of the study. Provides background on quantum computing fundamentals and current limitations in quantum programming languages. \\
\midrule

Methodology & Describes the use of the Constructive Research Method for artifact development. Justifies the iterative design, implementation, and evaluation process chosen for language and compiler development. \\
\midrule

Software Operations (\textbf{Included Publication}) & Presents the analysis and definition of essential high-level quantum operations. Includes a literature review of existing circuit primitives and a publication detailing the defined operational abstractions. \\
\midrule

Programming Language Development (\textbf{Included Publication}) & Details the design and specification of the new high-level quantum programming language. Describes language syntax, semantics, and proof-of-concept implementations. Contains a literature review of quantum programming languages where relevant. \\
\midrule

Language Compilation (\textbf{Included Publication}) & Discusses compilation approaches developed for the language, including dynamic and static compilation into general circuit structures. A publication comparing compilation techniques is included, supported by a review of related work in quantum compilation. \\
\midrule

Results & Summarizes the evaluation of the developed language and compilers. Presents results from simulation and hardware execution, where available provides qualitative results about the use of the language by non-experts. \\
\midrule

Future Directions & Explores opportunities for extending the language, optimizing static circuit compilation, and integrating the framework into larger quantum-classical hybrid systems. Identifies potential research directions for broadening accessibility in quantum software engineering. \\
\bottomrule
\end{tabular}
\end{table}





% Study Implications
\section{Study Implications}
This study will significantly enhance accessibility in quantum computing by introducing a high-level programming language with C-like abstraction. 
By decoupling low-level quantum mechanics from software design, the language enables software engineers to write quantum programs without expertise in quantum mechanics. 
The ability to compile into a general, static circuit structure promotes cross-platform compatibility, reducing hardware dependency and fostering broader adoption. 
The static circuit will provide a starting point for the development of steady state QPUs that do not require complex classical controllers to load and run circuit configurations.
We will las the groundwork for scalable quantum software development, supporting clearer reasoning, improved tooling, and future integration with classical systems. 

% References
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
